import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "path.grammar".
 */
public class Parser extends beaver.Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(Parser.class);

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN12 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 12];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN7 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 7];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN6 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 6];
		}
	};

	private final Action[] actions;

	public Parser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] lst$ClassDecl = ClassDecl
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [1] lst$ClassDecl = lst$ClassDecl ClassDecl
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [2] opt$lst$ClassDecl = 
			Action.RETURN,	// [3] opt$lst$ClassDecl = lst$ClassDecl
			RETURN2,	// [4] Program = MainClass opt$lst$ClassDecl; returns 'opt$lst$ClassDecl' although none is marked
			RETURN12,	// [5] MainClass = CLASS ID.i1 LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACK RBRACK ID.i2 RPAREN LBRACE Statement RBRACE RBRACE; returns 'i2' although more are marked
			new Action() {	// [6] lst$VarDecl = VarDecl
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [7] lst$VarDecl = lst$VarDecl VarDecl
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [8] opt$lst$VarDecl = 
			Action.RETURN,	// [9] opt$lst$VarDecl = lst$VarDecl
			new Action() {	// [10] lst$MethodDecl = MethodDecl
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [11] lst$MethodDecl = lst$MethodDecl MethodDecl
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [12] opt$lst$MethodDecl = 
			Action.RETURN,	// [13] opt$lst$MethodDecl = lst$MethodDecl
			RETURN2,	// [14] ClassDecl = CLASS ID.i LBRACE opt$lst$VarDecl opt$lst$MethodDecl RBRACE
			RETURN4,	// [15] ClassDecl = CLASS ID.i EXTENDS ID.i LBRACE opt$lst$VarDecl opt$lst$MethodDecl RBRACE; returns 'i' although more are marked
			RETURN2,	// [16] VarDecl = Type ID.i
			new Action() {	// [17] lst$Statement = Statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [18] lst$Statement = lst$Statement Statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [19] opt$lst$Statement = 
			Action.RETURN,	// [20] opt$lst$Statement = lst$Statement
			RETURN3,	// [21] MethodDecl = PUBLIC Type ID.i LPAREN FormalList RPAREN LBRACE opt$lst$VarDecl opt$lst$Statement RETURN Exp SEMI RBRACE
			new Action() {	// [22] lst$FormalRest = FormalRest
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [23] lst$FormalRest = lst$FormalRest FormalRest
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [24] opt$lst$FormalRest = 
			Action.RETURN,	// [25] opt$lst$FormalRest = lst$FormalRest
			RETURN3,	// [26] FormalList = Type ID opt$lst$FormalRest; returns 'opt$lst$FormalRest' although none is marked
			Action.NONE,  	// [27] FormalList = 
			RETURN3,	// [28] FormalRest = COMMA Type ID; returns 'ID' although none is marked
			RETURN3,	// [29] Type = INT LBRACK RBRACK; returns 'RBRACK' although none is marked
			Action.RETURN,	// [30] Type = BOOLEAN
			Action.RETURN,	// [31] Type = INT
			Action.RETURN,	// [32] Type = ID.i
			RETURN3,	// [33] Statement = LBRACE opt$lst$Statement RBRACE; returns 'RBRACE' although none is marked
			RETURN7,	// [34] Statement = IF LPAREN Exp RPAREN Statement ELSE Statement; returns 'Statement' although none is marked
			RETURN5,	// [35] Statement = WHILE LPAREN Exp RPAREN Statement; returns 'Statement' although none is marked
			RETURN5,	// [36] Statement = PRINT LPAREN Exp RPAREN SEMI; returns 'SEMI' although none is marked
			RETURN4,	// [37] Statement = ID EQUALS Exp SEMI; returns 'SEMI' although none is marked
			RETURN7,	// [38] Statement = ID LBRACK Exp RBRACK EQUALS Exp SEMI; returns 'SEMI' although none is marked
			RETURN3,	// [39] Exp = Exp Op Exp; returns 'Exp' although none is marked
			RETURN4,	// [40] Exp = Exp LBRACK Exp RBRACK; returns 'RBRACK' although none is marked
			RETURN3,	// [41] Exp = Exp DOT LENGTH; returns 'LENGTH' although none is marked
			RETURN6,	// [42] Exp = Exp DOT ID LPAREN ExpList RPAREN; returns 'RPAREN' although none is marked
			Action.RETURN,	// [43] Exp = INT_LIT.i
			Action.RETURN,	// [44] Exp = TRUE
			Action.RETURN,	// [45] Exp = FALSE
			Action.RETURN,	// [46] Exp = ID
			Action.RETURN,	// [47] Exp = THIS
			RETURN5,	// [48] Exp = NEW INT LBRACK Exp RBRACK; returns 'RBRACK' although none is marked
			RETURN4,	// [49] Exp = NEW ID LPAREN RPAREN; returns 'RPAREN' although none is marked
			RETURN2,	// [50] Exp = NOT Exp; returns 'Exp' although none is marked
			RETURN3,	// [51] Exp = LPAREN Exp RPAREN; returns 'RPAREN' although none is marked
			new Action() {	// [52] lst$ExpRest = ExpRest
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [53] lst$ExpRest = lst$ExpRest ExpRest
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [54] opt$lst$ExpRest = 
			Action.RETURN,	// [55] opt$lst$ExpRest = lst$ExpRest
			RETURN2,	// [56] ExpList = Exp opt$lst$ExpRest; returns 'opt$lst$ExpRest' although none is marked
			Action.NONE,  	// [57] ExpList = 
			RETURN2,	// [58] ExpRest = COMMA Exp; returns 'Exp' although none is marked
			Action.RETURN,	// [59] Op = TIMES
			Action.RETURN,	// [60] Op = PLUS
			Action.RETURN,	// [61] Op = MINUS
			Action.RETURN,	// [62] Op = LESS
			Action.RETURN	// [63] Op = AND
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
